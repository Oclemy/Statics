
# Middleware


You can add middleware to **FastAPI** applications.


A "middleware" is a function that works with every **request** before it is processed by any specific *path operation*. And also with every **response** before returning it.


* It takes each **request** that comes to your application.
* It can then do something to that **request** or run any needed code.
* Then it passes the **request** to be processed by the rest of the application (by some *path operation*).
* It then takes the **response** generated by the application (by some *path operation*).
* It can do something to that **response** or run any needed code.
* Then it returns the **response**.



Technical Details


If you have dependencies with `yield`, the exit code will run *after* the middleware.


If there were any background tasks (documented later), they will run *after* all the middleware.



## Create a middleware


To create a middleware you use the decorator `@app.middleware("http")` on top of a function.


The middleware function receives:


* The `request`.
* A function `call_next` that will receive the `request` as a parameter.
	+ This function will pass the `request` to the corresponding *path operation*.
	+ Then it returns the `response` generated by the corresponding *path operation*.
* You can then modify further the `response` before returning it.



```python
import time

from fastapi import FastAPI, Request

app = FastAPI()


@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
 response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
 return response

```


Technical Details


You could also use `from starlette.requests import Request`.


**FastAPI** provides it as a convenience for you, the developer. But it comes directly from Starlette.



### Before and after the `response`


You can add code to be run with the `request`, before any *path operation* receives it.


And also after the `response` is generated, before returning it.


For example, you could add a custom header `X-Process-Time` containing the time in seconds that it took to process the request and generate a response:



```python
import time

from fastapi import FastAPI, Request

app = FastAPI()


@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
 start_time = time.time()
    response = await call_next(request)
 process_time = time.time() - start_time
 response.headers["X-Process-Time"] = str(process_time)
    return response

```

## Other middlewares


You can later read more about other middlewares in the Advanced User Guide: Advanced Middleware.


You will read about how to handle CORS with a middleware in the next section.




# Advanced Middleware


In the main tutorial you read how to add Custom Middleware to your application.


And then you also read how to handle CORS with the `CORSMiddleware`.


In this section we'll see how to use other middlewares.


## Adding ASGI middlewares


As **FastAPI** is based on Starlette and implements the ASGI specification, you can use any ASGI middleware.


A middleware doesn't have to be made for FastAPI or Starlette to work, as long as it follows the ASGI spec.


In general, ASGI middlewares are classes that expect to receive an ASGI app as the first argument.


So, in the documentation for third-party ASGI middlewares they will probably tell you to do something like:



```python
from unicorn import UnicornMiddleware

app = SomeASGIApp()

new_app = UnicornMiddleware(app, some_config="rainbow")

```

But FastAPI (actually Starlette) provides a simpler way to do it that makes sure that the internal middlewares to handle server errors and custom exception handlers work properly.


For that, you use `app.add_middleware()` (as in the example for CORS).



```python
from fastapi import FastAPI
from unicorn import UnicornMiddleware

app = FastAPI()

app.add_middleware(UnicornMiddleware, some_config="rainbow")

```

`app.add_middleware()` receives a middleware class as the first argument and any additional arguments to be passed to the middleware.


## Integrated middlewares


**FastAPI** includes several middlewares for common use cases, we'll see next how to use them.



Technical Details


For the next examples, you could also use `from starlette.middleware.something import SomethingMiddleware`.


**FastAPI** provides several middlewares in `fastapi.middleware` just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette.



## `HTTPSRedirectMiddleware`


Enforces that all incoming requests must either be `https` or `wss`.


Any incoming requests to `http` or `ws` will be redirected to the secure scheme instead.



```python
from fastapi import FastAPI
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

app = FastAPI()

app.add_middleware(HTTPSRedirectMiddleware)


@app.get("/")
async def main():
    return {"message": "Hello World"}

```

## `TrustedHostMiddleware`


Enforces that all incoming requests have a correctly set `Host` header, in order to guard against HTTP Host Header attacks.



```python
from fastapi import FastAPI
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app = FastAPI()

app.add_middleware(
 TrustedHostMiddleware, allowed_hosts=["example.com", "*.example.com"]
)


@app.get("/")
async def main():
    return {"message": "Hello World"}

```

The following arguments are supported:


* `allowed_hosts` - A list of domain names that should be allowed as hostnames. Wildcard domains such as `*.example.com` are supported for matching subdomains. To allow any hostname either use `allowed_hosts=["*"]` or omit the middleware.


If an incoming request does not validate correctly then a `400` response will be sent.


## `GZipMiddleware`


Handles GZip responses for any request that includes `"gzip"` in the `Accept-Encoding` header.


The middleware will handle both standard and streaming responses.



```python
from fastapi import FastAPI
from fastapi.middleware.gzip import GZipMiddleware

app = FastAPI()

app.add_middleware(GZipMiddleware, minimum_size=1000)


@app.get("/")
async def main():
    return "somebigcontent"

```

The following arguments are supported:


* `minimum_size` - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to `500`.


## Other middlewares


There are many other ASGI middlewares.


For example:


To see other available middlewares check Starlette's Middleware docs and the ASGI Awesome List.



